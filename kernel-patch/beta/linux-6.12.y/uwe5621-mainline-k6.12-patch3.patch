From 00000000 Mon Sep 17 00:00:00 2001
From: Houjie <you@example.com>
Subject: [PATCH 3] uwe5621: activate net_device + cfg80211 ops for kernel 6.12

---
 drivers/net/wireless/uwe5621/core_main.c | 350 +++++++++++++++++++++++++++++++
 drivers/net/wireless/uwe5621/core_netdev.c | 270 +++++++++++++++++++++
 drivers/net/wireless/uwe5621/cfg80211_ops.c | 290 ++++++++++++++++++++++
 3 files changed, 910 insertions(+)
 create mode 100644 drivers/net/wireless/uwe5621/core_main.c
 create mode 100644 drivers/net/wireless/uwe5621/core_netdev.c
 create mode 100644 drivers/net/wireless/uwe5621/cfg80211_ops.c

diff --git a/drivers/net/wireless/uwe5621/core_main.c b/drivers/net/wireless/uwe5621/core_main.c
new file mode 100644
index 0000000..aaaaaaa
--- /dev/null
+++ b/drivers/net/wireless/uwe5621/core_main.c
@@ -0,0 +350,350 @@
+// Core init for UWE5621/UWE5631
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <net/cfg80211.h>
+
+extern struct wiphy *uwe_init_wiphy(void);
+extern struct net_device *uwe_create_netdev(struct wiphy *w);
+extern int sprd_bsp_init(void);
+extern void sprd_bsp_exit(void);
+
+static struct wiphy *global_wiphy;
+static struct net_device *global_ndev;
+
+int uwe5621_init_driver(void)
+{
+        int ret;
+
+        pr_info("uwe5621: Loading UWE5621 WiFi/BT driver\n");
+
+        ret = sprd_bsp_init();
+        if (ret) {
+                pr_err("uwe5621: BSP init failed\n");
+                return ret;
+        }
+
+        global_wiphy = uwe_init_wiphy();
+        if (!global_wiphy) {
+                pr_err("uwe5621: wiphy init failed\n");
+                return -ENOMEM;
+        }
+
+        global_ndev = uwe_create_netdev(global_wiphy);
+        if (!global_ndev)
+                return -ENOMEM;
+
+        ret = wiphy_register(global_wiphy);
+        if (ret) {
+                pr_err("uwe5621: failed to register wiphy\n");
+                return ret;
+        }
+
+        ret = register_netdev(global_ndev);
+        if (ret) {
+                pr_err("uwe5621: failed to register netdev\n");
+                return ret;
+        }
+
+        pr_info("uwe5621: driver initialized OK\n");
+        return 0;
+}
+EXPORT_SYMBOL_GPL(uwe5621_init_driver);
+
+
+void uwe5621_exit_driver(void)
+{
+        unregister_netdev(global_ndev);
+        wiphy_unregister(global_wiphy);
+        sprd_bsp_exit();
+
+        pr_info("uwe5621: driver unloaded\n");
+}
+EXPORT_SYMBOL_GPL(uwe5621_exit_driver);

MODULE_LICENSE("GPL");



diff --git a/drivers/net/wireless/uwe5621/core_netdev.c b/drivers/net/wireless/uwe5621/core_netdev.c
new file mode 100644
index 0000000..bbbbbbb
--- /dev/null
+++ b/drivers/net/wireless/uwe5621/core_netdev.c
@@ -0,0 +270,270 @@
+// Net_device integration for UWE5621
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+
+static int uwe_open(struct net_device *ndev)
+{
+        netif_start_queue(ndev);
+        pr_info("uwe5621: netdev opened\n");
+        return 0;
+}
+
+static int uwe_stop(struct net_device *ndev)
+{
+        netif_stop_queue(ndev);
+        pr_info("uwe5621: netdev stopped\n");
+        return 0;
+}
+
+/*
+ * TX path â€” forward to Spreadtrum transmission queue
+ */
+static netdev_tx_t uwe_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+        extern int sprdwl_tx(struct sk_buff *);
+        sprdwl_tx(skb);
+        return NETDEV_TX_OK;
+}
+
+
+/*
+ * Basic netdev setup
+ */
+struct net_device *uwe_create_netdev(struct wiphy *w)
+{
+        struct net_device *ndev;
+
+        ndev = alloc_etherdev(0);
+        if (!ndev)
+                return NULL;
+
+        ether_setup(ndev);
+
+        ndev->netdev_ops = &(struct net_device_ops) {
+                .ndo_open       = uwe_open,
+                .ndo_stop       = uwe_stop,
+                .ndo_start_xmit = uwe_xmit,
+        };
+
+        eth_hw_addr_random(ndev);
+
+        return ndev;
+}
+EXPORT_SYMBOL_GPL(uwe_create_netdev);

MODULE_LICENSE("GPL");




diff --git a/drivers/net/wireless/uwe5621/cfg80211_ops.c b/drivers/net/wireless/uwe5621/cfg80211_ops.c
new file mode 100644
index 0000000..ccccccc
--- /dev/null
+++ b/drivers/net/wireless/uwe5621/cfg80211_ops.c
@@ -0,0 +290,290 @@
+// cfg80211 ops for UWE5621 kernel 6.12
+
+#include <net/cfg80211.h>
+
+extern int uwe_report_scan(struct wiphy *, struct ieee80211_channel *,
+                           const u8 *, size_t, int);
+extern int sprdwl_start_scan(struct wiphy *);
+extern int sprdwl_stop_scan(struct wiphy *);
+
+static int uwe_scan(struct wiphy *wiphy, struct cfg80211_scan_request *req)
+{
+        pr_info("uwe5621: start scan\n");
+        return sprdwl_start_scan(wiphy);
+}
+
+static int uwe_abort_scan(struct wiphy *wiphy, struct wireless_dev *wdev)
+{
+        pr_info("uwe5621: abort scan\n");
+        return sprdwl_stop_scan(wiphy);
+}
+
+/*
+ * connect/disconnect (will work in PATCH 4)
+ */
+static int uwe_connect(struct wiphy *w, struct net_device *ndev,
+                       struct cfg80211_connect_params *p)
+{
+        pr_info("uwe5621: connect request (SSID=%*phN)\n",
+                p->ssid_len, p->ssid);
+        return 0;
+}
+
+static int uwe_disconnect(struct wiphy *w, struct net_device *ndev,
+                          u16 reason)
+{
+        pr_info("uwe5621: disconnect\n");
+        return 0;
+}
+
+
+/*
+ * cfg80211 ops struct
+ */
+struct cfg80211_ops uwe_cfg80211_ops = {
+        .scan            = uwe_scan,
+        .abort_scan      = uwe_abort_scan,
+        .connect         = uwe_connect,
+        .disconnect      = uwe_disconnect,
+};
+
+EXPORT_SYMBOL_GPL(uwe_cfg80211_ops);

MODULE_LICENSE("GPL");

-- 
2.39.3
